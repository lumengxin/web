                  ECMAScript6入门-阮一峰

1.ECMAScript6简介
	 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。
	1.1 es和js的关系：
	 es是js的规范，js是es的一种实现。日常场合，这两个词是可以互换的。
	1.2 es6和es2015关系：
	 ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等,而 ES2015 则是正式名称。
	1.3 部署进度：
	 查看node已实现的es6特性：node --v8-options | grep harmony
	 使用的node环境对es6的支持程度：npm install -g es-checker; es-checker
	1.4 Babel转码器：
	 一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。
	 安装：npm install --save-dev @babel/core

2.let和const命令
 2.1 let
  2.1.1 基本用法：声明变量，只在所在代码块有效。类似var。
	2.1.2 不存在变量提升：let声明的变量一定要在声明后使用
	 //var foo;  //var 变量提升
	 console.log(foo); //>undefined 变量foo存在，无值
	 var foo = 2; 
	 //let 报错 ReferenceError
	2.1.3 暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。
	2.1.4 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。
	 //报错
	 function func() {
		let a = 10;
		var a = 1; 
	 }
	 function func(arg) {
		let arg;
	 }
	 func();
	 //不报错
	 function func(arg) {
		{
			let arg;
		}
	 }
	 func();
 2.2 块级作用域：es5只有全局、函数作用域，使用不合理。
  let为js新增了块级作用域。
	ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 的块级作用域必须有大括号。
 2.3 const
  2.3.1 用法：声明一个只读的常量。一旦声明，常量的值就不能改变。一旦声明变量，就必须立即初始化，不能留到以后赋值。作用域等都和let相同。
	2.3.2 本质：不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针,将一个对象声明为常量必须非常小心。
	 const foo = Object.freeze({}); //将对象冻结
	 //常规模式，不起作用；严格模式，报错
	 foo.prop = 1;
	 2.3.3 es6六种声明变量方法：var/function, let/const, import/class
 2.4 顶级对象的属性
  顶级对象：浏览器中指window对象,node中指global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
	es6中：var命令和function命令声明的全局变量，依旧是顶层对象的属性；let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
 2.5 globalThis对象
  avaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。
	-浏览器：window
	-浏览器和Web Worker：self也指向顶层对象
	-node:global,其他环境不支持
 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。
  -全局环境中，this会返回顶层对象；node,es6模块中，返回是当前模块；
	-函数里的this,不是对象时，可以。严格模式下，返回undefined；
 很难找到一种方法，可以在所有情况下，都取到顶层对象。有一个提案，在语言标准的层面，引入globalThis作为顶层对象。

3.变量的解构赋值
 3.1 数组
  3.1.1 用法：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
	 let [a,b,c] = [1,,3];
	 let [foo] = []; //>undefined,解构不成功
	 let [x,y] = [1,2,3]; //不完全解构
	3.1.2 默认值：解构赋值允许指定默认值。
	 let [foo =  true] = []; 
	 foo;  //true
 3.2 对象
  数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
	3.2.1 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
	 //将Math对象的对数，正弦，余弦三个方法，赋值到对应的变量上
	 let { log, sin, cos } = Math;
	 //将console.log赋值到log变量
	 const { log } = console;
	 log('hello');  //hello
	3.2.2 默认值
	 var {x: y = 3} = {x: 1};
   x; //1
	 y; //3
	3.2.3 注意
	 -如果要将一个已经声明的变量用于解构赋值，必须非常小心。
	 -解构赋值允许等号左边的模式之中，不放置任何变量名。
	 -由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
 3.3 字符串
  字符串被转换成了一个类似数组的对象。类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
	 let {length:len} = 'hello';
	 len; //5
 3.4 数值和布尔值
  解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
 3.5 函数参数
  [[1,2],[3,4]].map(([a,b]) => a + b); //[3,7]
 3.6 圆括号问题
  对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。
  ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
	3.6.1 不能使用：
	 -变量声明语句
	  let [(a)] = [1];
	 -函数参数
   -赋值语句的模式
	  ({p:a}) = {p:23};
  3.6.2 可以使用：
	 赋值语句的非模式部分，可以使用圆括号
	  [(b)] = [3];
 3.7 用途
  --交换变量的值
	--从函数返回多个值
  --函数参数的定义
	--提取 JSON 数据
	--函数参数的默认值

4.字符串的扩展
 	4.1 字符的Unicode表示法
	 ES6 加强了对 Unicode 的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。(\u0000~\uFFFF)
	  "\uD842\uDFB7"; //"𠮷"
		"\u{41}\u{42}\u{43}"
		// "ABC"大括号表示法与四字节的 UTF-16 编码等价
	4.2 字符串的遍历器接口
	 是字符串可以被for...of循环遍历
	4.3 JSON.stringify() 的改造
	 遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。
  4.4 模板字符串：``,可以嵌入变量${name},空格换行都会保留。可以调用函数。
	4.5 模板编译：模板中可以使用<% %>放置js代码。

5.字符串的新增方法
	5.1 String.fromCodePoint():识别大于0×FFFF的字符。
	5.2 String.raw():返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。
	5.3 codePointAt():能够正确处理 4 个字节储存的字符，返回一个字符的码点。
	 js内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节,对于那些4个字节字符（码点大于0xFFFF），js认为是两个字符。
	5.4 normalize():将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。
	5.5 js只有indexOf()方法，来确定一个字符串是否包含在另一个字符串中。es中：
	 -includes()：返回布尔值，表示是否找到了参数字符串。
	 -startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
	 -endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
	5.6 repeat():将原字符串重复n次。
	5.7 padStart():长度补全。
	 'x'.padStart(5,'ab'); //ababx
	 'x'.padEnd(4,'ab');   //xaba
	5.8 trimStart():消除头部空格。
			trim(),trimEnd()
	5.9 matchAll():返回一个正则表达式在当前字符串的所有匹配。
	
6.正则的扩展
	6.1 RegExp 构造函数：es6中，第一个参数是一个正则对象，可以使用第二个参数指定修饰符。
	6.2 字符串的正则方法：match(),replace(),search(),split()
	6.3 u修饰符：“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。


  

